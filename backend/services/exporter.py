"""
Export Service
Exports transcription results to various formats (Markdown, etc.)
Inspired by AI-Video-Transcriber: https://github.com/wendy7756/AI-Video-Transcriber
"""
import logging
from typing import Optional, List, Dict
from datetime import datetime

logger = logging.getLogger(__name__)


def export_to_markdown(
    transcript: Optional[str] = None,
    summary: Optional[dict] = None,
    translation: Optional[dict] = None,
    title: str = "Transcription",
    language: Optional[str] = None,
    platform: Optional[str] = None,
    duration: Optional[float] = None,
    segments: Optional[List[dict]] = None,
    include_timestamps: bool = False,
) -> str:
    """
    Export transcription result to Markdown format
    
    Args:
        transcript: The transcript text
        summary: Summary dict with 'summary', 'key_points', 'topics'
        translation: Translation dict with 'translated_text', 'source_language', 'target_language'
        title: Title of the transcription
        language: Detected language of transcript
        platform: Source platform (youtube, tiktok, etc.)
        duration: Video duration in seconds
        segments: List of transcript segments with timestamps
        include_timestamps: Whether to include timestamps in transcript
    
    Returns:
        Markdown formatted string
    """
    lines = []
    
    # Header
    lines.append(f"# {title}")
    lines.append("")
    
    # Metadata
    metadata = []
    if platform:
        metadata.append(f"**Platform:** {platform.title()}")
    if language:
        metadata.append(f"**Language:** {language}")
    if duration:
        minutes = int(duration // 60)
        seconds = int(duration % 60)
        metadata.append(f"**Duration:** {minutes}:{seconds:02d}")
    metadata.append(f"**Generated:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}")
    
    if metadata:
        lines.append(" | ".join(metadata))
        lines.append("")
        lines.append("---")
        lines.append("")
    
    # Summary Section
    if summary and summary.get("summary"):
        lines.append("## Summary")
        lines.append("")
        lines.append(summary["summary"])
        lines.append("")
        
        # Key Points
        key_points = summary.get("key_points", [])
        if key_points:
            lines.append("### Key Points")
            lines.append("")
            for point in key_points:
                lines.append(f"- {point}")
            lines.append("")
        
        # Topics
        topics = summary.get("topics", [])
        if topics:
            lines.append("### Topics")
            lines.append("")
            lines.append(", ".join(f"`{topic}`" for topic in topics))
            lines.append("")
        
        lines.append("---")
        lines.append("")
    
    # Transcript Section
    if transcript:
        lines.append("## Transcript")
        lines.append("")
        
        if include_timestamps and segments:
            # Include timestamps with segments
            for segment in segments:
                start = segment.get("start_time", 0)
                minutes = int(start // 60)
                seconds = int(start % 60)
                text = segment.get("text", "")
                lines.append(f"**[{minutes}:{seconds:02d}]** {text}")
                lines.append("")
        else:
            # Plain text transcript with paragraph formatting
            paragraphs = format_transcript_paragraphs(transcript)
            for para in paragraphs:
                lines.append(para)
                lines.append("")
        
        lines.append("---")
        lines.append("")
    
    # Translation Section
    if translation and translation.get("translated_text"):
        source_lang = translation.get("source_language_name", translation.get("source_language", ""))
        target_lang = translation.get("target_language_name", translation.get("target_language", ""))
        
        lines.append(f"## Translation ({source_lang} -> {target_lang})")
        lines.append("")
        
        # Format translation text
        paragraphs = format_transcript_paragraphs(translation["translated_text"])
        for para in paragraphs:
            lines.append(para)
            lines.append("")
    
    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Generated by ClipAI Video Transcriber*")
    
    return "\n".join(lines)


def format_transcript_paragraphs(text: str, sentences_per_paragraph: int = 4) -> List[str]:
    """
    Format transcript text into readable paragraphs
    
    Args:
        text: The transcript text
        sentences_per_paragraph: Number of sentences per paragraph
    
    Returns:
        List of paragraph strings
    """
    if not text:
        return []
    
    # Split by sentence endings
    import re
    sentences = re.split(r'(?<=[.!?])\s+', text.strip())
    
    paragraphs = []
    current = []
    
    for sentence in sentences:
        sentence = sentence.strip()
        if not sentence:
            continue
        
        current.append(sentence)
        
        if len(current) >= sentences_per_paragraph:
            paragraphs.append(" ".join(current))
            current = []
    
    # Add remaining sentences
    if current:
        paragraphs.append(" ".join(current))
    
    return paragraphs


def export_to_srt(
    segments: List[dict],
    output_path: Optional[str] = None,
) -> str:
    """
    Export segments to SRT subtitle format
    
    Args:
        segments: List of segments with 'text', 'start_time', 'end_time'
        output_path: Optional path to save file
    
    Returns:
        SRT formatted string
    """
    lines = []
    
    for i, segment in enumerate(segments, 1):
        start = segment.get("start_time", 0)
        end = segment.get("end_time", start + 2)
        text = segment.get("text", "")
        
        # Format timestamp for SRT (HH:MM:SS,mmm)
        start_str = format_srt_timestamp(start)
        end_str = format_srt_timestamp(end)
        
        lines.append(str(i))
        lines.append(f"{start_str} --> {end_str}")
        lines.append(text)
        lines.append("")
    
    srt_content = "\n".join(lines)
    
    if output_path:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(srt_content)
    
    return srt_content


def format_srt_timestamp(seconds: float) -> str:
    """Format seconds to SRT timestamp format (HH:MM:SS,mmm)"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"


def export_to_vtt(
    segments: List[dict],
    output_path: Optional[str] = None,
) -> str:
    """
    Export segments to WebVTT subtitle format
    
    Args:
        segments: List of segments with 'text', 'start_time', 'end_time'
        output_path: Optional path to save file
    
    Returns:
        VTT formatted string
    """
    lines = ["WEBVTT", ""]
    
    for i, segment in enumerate(segments, 1):
        start = segment.get("start_time", 0)
        end = segment.get("end_time", start + 2)
        text = segment.get("text", "")
        
        # Format timestamp for VTT (HH:MM:SS.mmm)
        start_str = format_vtt_timestamp(start)
        end_str = format_vtt_timestamp(end)
        
        lines.append(f"{start_str} --> {end_str}")
        lines.append(text)
        lines.append("")
    
    vtt_content = "\n".join(lines)
    
    if output_path:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(vtt_content)
    
    return vtt_content


def format_vtt_timestamp(seconds: float) -> str:
    """Format seconds to VTT timestamp format (HH:MM:SS.mmm)"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"


def export_to_json(
    transcript: Optional[str] = None,
    summary: Optional[dict] = None,
    translation: Optional[dict] = None,
    segments: Optional[List[dict]] = None,
    metadata: Optional[dict] = None,
) -> dict:
    """
    Export transcription result to JSON format
    
    Returns:
        Dict ready for JSON serialization
    """
    result = {
        "generated_at": datetime.utcnow().isoformat(),
        "generator": "ClipAI Video Transcriber",
    }
    
    if metadata:
        result["metadata"] = metadata
    
    if transcript:
        result["transcript"] = transcript
    
    if segments:
        result["segments"] = segments
    
    if summary:
        result["summary"] = summary
    
    if translation:
        result["translation"] = translation
    
    return result
